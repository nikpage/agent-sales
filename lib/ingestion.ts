// Path: lib/ingestion.ts

import { JSDOM } from 'jsdom';
import { Buffer } from 'buffer';

function gmailIdToUuid(gmailId: string): string {
  const padded = gmailId.padStart(32, '0');
  return `${padded.slice(0, 8)}-${padded.slice(8, 12)}-${padded.slice(12, 16)}-${padded.slice(16, 20)}-${padded.slice(20)}`;
}

function decodeBase64(data?: string | null): string {
  if (!data) return '';
  return Buffer.from(data, 'base64').toString('utf8');
}

function extractEmailBody(payload: any): string {
  if (!payload) return '';

  if (payload.parts) {
    for (const part of payload.parts) {
      if (part.mimeType === 'text/plain' && part.body?.data) {
        return decodeBase64(part.body.data);
      }
      if (part.mimeType === 'text/html' && part.body?.data) {
        const html = decodeBase64(part.body.data);
        const dom = new JSDOM(html);
        return dom.window.document.body.textContent || '';
      }
      if (part.parts) {
        const nested = extractEmailBody(part);
        if (nested) return nested;
      }
    }
  }

  if (payload.body?.data) return decodeBase64(payload.body.data);
  return '';
}

function cleanText(text?: string | null): string {
  if (!text) return '';
  let cleaned = text;
  cleaned = cleaned.split(/^On .* wrote:$/m)[0];
  cleaned = cleaned.split(/^Begin forwarded message:$/m)[0];
  cleaned = cleaned.split(/^---$/m)[0];
  cleaned = cleaned.split(/^--\s*$/m)[0];
  return cleaned.trim();
}

export type EmailData = {
  id: string;              // deterministic uuid derived from Gmail message id (used as messages.external_id)
  originalId: string;      // Gmail message id
  threadId: string;        // Gmail thread id
  from: string;
  subject: string;
  timestamp: string;
  rawText: string;
  cleanedText: string;
};

export async function getEmailDetails(gmail: any, messageId: string): Promise<EmailData> {
  const res = await gmail.users.messages.get({
    userId: 'me',
    id: messageId,
    format: 'full',
  });

  const headers = res.data?.payload?.headers || [];
  const from = headers.find((h: any) => h.name === 'From')?.value || 'Unknown';
  const subject = headers.find((h: any) => h.name === 'Subject')?.value || '(No Subject)';

  const internalDate = Number(res.data?.internalDate);
  const timestamp = Number.isFinite(internalDate)
    ? new Date(internalDate).toISOString()
    : new Date().toISOString();

  const rawText = extractEmailBody(res.data?.payload);
  const cleanedText = cleanText(rawText);

  return {
    id: gmailIdToUuid(String(res.data.id)),
    originalId: String(res.data.id),
    threadId: String(res.data.threadId),
    from,
    subject,
    timestamp,
    rawText,
    cleanedText,
  };
}

/**
 * Insert into messages using DB schema:
 * - messages.id is generated by DB
 * - messages.external_id stores deterministic uuid from Gmail id
 * - messages.external_thread_id stores Gmail threadId
 */
export async function storeMessage(
  supabase: any,
  userId: string,
  cpId: string,
  emailData: EmailData
): Promise<string> {
  const { data: existing, error: existErr } = await supabase
    .from('messages')
    .select('id')
    .eq('external_id', emailData.id)
    .maybeSingle();

  if (existErr) throw existErr;
  if (existing) return existing.id as string;

  const { data: inserted, error: insertErr } = await supabase
    .from('messages')
    .insert({
      user_id: userId,
      cp_id: cpId,
      direction: 'inbound',
      raw_text: emailData.rawText,
      cleaned_text: emailData.cleanedText,
      timestamp: emailData.timestamp,
      external_id: emailData.id,
      external_thread_id: emailData.threadId,
    })
    .select('id')
    .single();

  if (insertErr) throw insertErr;
  return inserted.id as string;
}
